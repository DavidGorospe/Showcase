// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

// expects: blinn_phong, perlin_noise
void main()
{
  vec3 ka = vec3(0.1);
  vec3 kd;
  vec3 ks = vec3(1.0);
  float shininess = 1000.0;

  float orbit_radius = 3.0;
  float orbit_speed = M_PI * 2.0 / 8.0; // 1 orbit per 8 seconds
  float orbit_angle = animation_seconds * orbit_speed;

  vec3 p = normalize(sphere_fs_in); 

  if (is_moon) {
    float c = cos(orbit_angle);
    float s = sin(orbit_angle);

    mat4 rot_y = mat4(1.0);
    rot_y[0][0] =  c;  rot_y[0][2] =  s;
    rot_y[2][0] = -s;  rot_y[2][2] =  c;

    vec4 rotated = rot_y * vec4(p, 0.0);
    p = rotated.xyz;
  }

  // Generate perlin noise 
  float n = 0.0;
  float freq = 1.0;
  float amp = 1.0;
  for (int i = 0; i < 5; i++) {
    n += amp * perlin_noise(p * freq);
    freq *= 2.0;
    amp *= 0.5;
  }
  n = 0.5 * n + 0.5; 

  // Set colours
  if (is_moon) {
    // Moon
    vec3 baseA = vec3(0.3, 0.3, 0.3);
    vec3 baseB = vec3(0.8, 0.8, 0.8);
    kd = mix(baseA, baseB, n);
  } else {
    // Planet
    vec3 baseA = vec3(0.0, 0.1, 0.5);
    vec3 baseB = vec3(0.0, 0.6, 0.2);
    kd = mix(baseA, baseB, n);
  }

  vec3 light_pos_world = vec3(
    orbit_radius * cos(orbit_angle),
    3.0,
    orbit_radius * sin(orbit_angle)
  );

  vec3 frag_pos_view = view_pos_fs_in.xyz;
  vec3 light_pos_view = (view * vec4(light_pos_world, 1.0)).xyz;

  vec3 nrm = normalize(normal_fs_in);
  vec3 v = normalize(-frag_pos_view);
  vec3 l = normalize(light_pos_view - frag_pos_view);

  color = blinn_phong(ka, kd, ks, shininess, nrm, v, l);
}
